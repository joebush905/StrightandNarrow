class Motor(object):
    """ A ``motor`` object is used to control a DC motor using the L298N dual H-bridge.
    The Motor class has methods to change the direction of the motor by setting
    the IN1/IN2 pins:
    - ``Motor.set_forwards()``
    - ``Motor.set_backwards()``
     and a method to change the duty cycle (0-100%) of the PWM output:
    - ``Motor.duty(pwm)``
    """

    def __init__(self, side, in1_pin, in2_pin, en_pin):
        """
        :rtype: object
        :type side: str
        :type in1_pin: str
        :type in2_pin: str
        :type en_pin: str
        The arguments are:
        - ``side``  should be the strings: "left" or "right". Used to specify motor.
        - ``in1_pin`` should be a valid Pin name string.
        - ``in2_pin`` should be a valid Pin name string
        - ``en_pin`` should be the strings: "D4" or "D5"
        Usage Model::
        # Initialise motor instance
        left_motor = Motor("left", "D6", "D7", "D4")
        # Set motor direction to forwards, and duty cycle to 70%
        left_motor.set_forwards()
        left_motor.duty(70)
        Note: This module assumes your en_pin is attached to either D4 or D5.
        To use another pin, you must choose the correct timer & channel
        appropriate to that pin. For a list of pin/timer/channel pairings,
        please see the pin-out diagram for the Nucleo L476RG:
        https://os.mbed.com/platforms/ST-Nucleo-L476RG/#arduino-compatible-headers
        E.g. The Arduino pin D2 is labelled `PWM1/3' indicating Timer 1, Channel 3.
        Modifications must be made to this library as appropriate, and this is
        left as an open problem for the student :) Have fun!
        """
        from pyb import Timer
        from machine import Pin
        # Declare a variable to keep track of which motor is left/right
        self.side = side
        print("Initialising", self.side, "motor...")
        # Declare GPIO pins for direction IN1 and IN2 pins
        self.IN1 = Pin(in1_pin, Pin.OUT)
        self.IN2 = Pin(in2_pin, Pin.OUT)
        # Declare GPIO pins for PWM EN pin
        self.EN = Pin(en_pin)
        # Set timer number and channel depending on pin chosen as input
        if en_pin == "D4":
            _tim = 3
            _channel = 2
        elif en_pin == "D5":
            _tim = 3
            _channel = 1
        # Declare a Timer instance for PWM output on EN pin and configure the channel
        self.tim = Timer(_tim, freq=20000)  # Frequency at 20kHz to be outside human hearing
        self.ch = self.tim.channel(_channel, Timer.PWM, pin=self.EN)
        print("Motor", self.side, "initialised!")

    def duty(self, pwm):
        self.ch.pulse_width_percent(pwm)

    def set_forwards(self):
        if self.side == "left":
            self.IN1.on()
            self.IN2.off()
        else:  # only other motor is the right motor
            self.IN1.off()
            self.IN2.on()

    def set_backwards(self):
        if self.side == "left":
            self.IN1.off()
            self.IN2.on()
        else:
            self.IN1.on()
            self.IN2.off()

class Encoder(object):
    def __init__(self, pin_left, pin_right):
        from machine import Pin
        self.forward = True
        self.pin_left = Pin(pin_left, Pin.IN)
        self.pin_right = Pin(pin_right, Pin.IN)
        self._count_left = 0
        self._count_right = 0
        self.left_interrupt = self.pin_left.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=self.left_callback)
        self.right_interrupt = self.pin_right.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=self.right_callback)

    # Callback functions are used to `handle' desired operations immediately,
    # whenever a rising/falling edge triggers an `interrupt'
    def left_callback(self, line):
        # Add or subtract 1 from the left encoder count based on direction
        self._count_left += 1 if self.forward else -1

    def right_callback(self, line):
        # Add or subtract 1 from the right encoder count based on direction
        self._count_right += 1 if self.forward else -1

    def get_left(self):
        return self._count_left

    def get_right(self):
        return self._count_right

    def clear_count(self):
        # Reset the counts of both encoders to zero
        self._count_left = 0
        self._count_right = 0

class HCSR04:

    def init(self, trigger_pin, echo_pin, echo_timeout_us=40002/(340.291e-3)):
        """
        - trigger_pin: Output pin to send pulses
        - echo_pin: Input pin listens for reflection to estimate time of flight.
        - echo_timeout_us: Timeout in microseconds to listen to echo pin.
        By default the timeout is set to the max range limit of the sensor, 4m
        """
        # Initialise constants
        self.echo_timeout_us = int(echo_timeout_us)
        self.speed_sound = 340.29  # m/s

        # Initialise the TRIG output pin
        self.trigger = Pin(trigger_pin, mode=Pin.OUT)
        self.trigger.value(0)

        # Initialise the ECHO input pin
        self.echo = Pin(echo_pin, mode=Pin.IN)

    def distance_mm(self):
        """
        Estimate distance to obstacle in front of the ultrasonic sensor in mm.
        Sends a 10us pulse to 'trigger' pin and listens on 'echo' pin.
        We use the method machine.time_pulse_us() to count the microseconds
        passed before the echo is received.
        The time of flight is used to calculate the estimated distance.
        """
        # Send a 10us HIGH pulse to trigger the ultrasonic burst
        self.trigger.value(1)
        time.sleep(0.01)
        self.trigger.value(0)
        # Read length of time pulse
        duration = machine.time_pulse_us(self.echo, 1, self.echo_timeout_us)
        # Calculate the distance in mm, based on the delay before we hear
        # an echo and the constant speed of sound.
        # Note: duration is halved as the audio wave must travel there and back.
        mm = 0.5 * duration * 1e-6 * self.speed_sound * 1e3
        return mm

from machine import Pin
import time
from motor import Motor
from encoder import Encoder
from time import sleep
import ultrasonic
from math import pi
motor_left = Motor("left", "D6", "D7", "D4")
motor_right = Motor("right", "D9", "D8", "D5")
ENC_L = "D2"
ENC_R = "D3"
enc = Encoder(ENC_L, ENC_R)
TRIG = "D13"
ECHO = "D12"
ultrasonic_sensor = ultrasonic.HCSR04(TRIG, ECHO)

def ClicksNeeded(angle):
    WheelDiameter = 65  ##diameter in mm
    WheelBase = 140  ##wheel base in mm
    AngelTurn = angle * pi/180  # defines the angle we want to turn
    TurningRadius = WheelBase / 2
    c = WheelDiameter * pi
    l = AngelTurn * TurningRadius
    total = (l/c)*20
    return round(total)
x = 80
y = 78
dist = ultrasonic_sensor.distance.mm()
while True:
    enc.clear_count()
    while dist > 200:
        motor_left.set_forwards()
        motor_right.set_forwards()
        motor_left.duty(x)
        motor_right.duty(y) ##approx straight from graph produced from workshop
        sleep(0.1)
        a = enc.get_left()
        b = enc.get_right()
        if a > b: #turning right
            x += -1
            y += 1

        elif b > a: #turning left
            x = x + 1
            y = y - 1
        else:
            sleep(0.1)
        print(x, y)
    dist = ultrasonic_sensor.distance.mm()
    while dist < 200:
        motor_left.duty(0)
        motor_right.duty(0)
        enc.clear_count()
        motor_left.set_backwards()  # assumed that they still turn the same rate
        motor_right.set_forwards()
        motor_left.duty(x)
        motor_right.duty(y)
        sleep(0.1)
        c = ClicksNeeded(90)
        a = enc.get_left()
        b = enc.get_right()
        if a+b < 2*c:
            a = enc.get_left()
            b = enc.get_right()
        else:
            motor_left.duty(0)
            motor_right.duty(0)
            sleep(0.1)
            dist = ultrasonic_sensor.distance.mm()
