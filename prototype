from motor import Motor
from time import sleep
from encoder import Encoder
import ultrasonic
from math import pi

motor_left = Motor("left", "D6", "D7", "D4")
motor_right = Motor("right", "D9", "D8", "D5")
ENC_L = "D2"
ENC_R = "D3"
enc = Encoder(ENC_L, ENC_R)
TRIG = "D10"
ECHO = "D11"
ultrasonic_sensor = ultrasonic.HCSR04(TRIG, ECHO)


def clicksneeded(angle):
    wheeldiameter = 65
    """diameter in mm"""
    wheelbase = 140
    """wheel base in mm"""
    angelturn = angle * pi/180
    """defines the angle we want to turn"""
    turningradius = wheelbase / 2
    cee = wheeldiameter * pi
    length = angelturn * turningradius
    total = (length/cee)*20
    return round(total)


x = 80
y = 78
dist = ultrasonic_sensor.distance_mm()
while True:
    enc.clear_count()
    while dist > 200:
        motor_left.set_forwards()
        motor_right.set_forwards()
        motor_left.duty(x)
        motor_right.duty(y)  # approx straight from graph produced from workshop
        sleep(0.1)
        a = enc.get_left()
        b = enc.get_right()
        if a > b:  # turning right
            x += -1
            y += 1

        elif b > a:  # turning left
            x = x + 1
            y = y - 1
        else:
            sleep(0.1)
        print(x, y)
    dist = ultrasonic_sensor.distance_mm()
    while dist < 200:
        motor_left.duty(0)
        motor_right.duty(0)
        enc.clear_count()
        motor_left.set_backwards()  # assumed that they still turn the same rate
        motor_right.set_forwards()
        motor_left.duty(x)
        motor_right.duty(y)
        sleep(0.1)
        c = clicksneeded(90)
        a = enc.get_left()
        b = enc.get_right()
        if a+b < 2*c:
            a = enc.get_left()
            b = enc.get_right()
        else:
            motor_left.duty(0)
            motor_right.duty(0)
            sleep(0.1)
            dist = ultrasonic_sensor.distance_mm()
